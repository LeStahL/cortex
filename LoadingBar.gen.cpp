#include "LoadingBar.hpp"

const char *loadingBarSource =
"\n#version 130"
"\n"
"uniform vec2 iResolution;"
"uniform float iProgress;"
""
"out vec4 gl_FragColor;"
""
"const float pi=acos(-1.);"
"const vec3 c=vec3 (1.,0.,-1.);"
"const float ssize=.6;"
""
""
"void rand(in vec2 x,out float n);"
"void lfnoise(in vec2 t,out float n);"
"void smoothmin(in float a,in float b,in float k,out float dst);"
"void dsmoothvoronoi(in vec2 x,in float sm,out float d,out vec2 z);"
"void dbox3(in vec3 x,in vec3 b,out float d);"
"void zextrude(in float z,in float d2d,in float h,out float d);"
"void add(in vec2 sda,in vec2 sdb,out vec2 sdf);"
"void dlinesegment(in vec2 x,in vec2 p1,in vec2 p2,out float d);"
""
"void main_scene(in vec3 x,out vec2 sdf)"
"{"
"vec2 na;"
"lfnoise(12.*x.xy,na.x);"
"lfnoise(12.*x.xy-1337.,na.y);"
"na=.5+.5*na;"
""
"float v;"
"vec2 vi;"
"dsmoothvoronoi(12.*x.xy-.8*na,.3,v,vi);"
"v/=12.;"
"v=abs(v)-.0001;"
"zextrude(x.z+.01,v,.02,v);"
""
"float d=x.z+.01;"
"smoothmin(d,v,.06*na.x,d);"
""
"dsmoothvoronoi(32.*x.xy-2.4*na,.3,v,vi);"
"v/=32.;"
"v=abs(v)-.0001;"
"zextrude(x.z+.01+d,v,.001,v);"
""
"smoothmin(d,v,.018*na.y,d);"
""
"sdf=vec2 (abs(d-.01)-.001,1.);"
"add(sdf,vec2 (d,3.),sdf);"
""
"}"
""
"\n#define normal(o,t)void o(in vec3 x,out vec3 n,in float dx){vec2 s,na;t(x,s);t(x+dx*c.xyy,na);n.x=na.x;t(x+dx*c.yxy,na);n.y=na.x;t(x+dx*c.yyx,na);n.z=na.x;n=normalize(n-s.x);}"
"\nnormal(main_normal,main_scene)"
""
"\n#define march(id,sid,exit,step)void id(out vec3 x,in vec3 o,inout float d,in vec3 dir,in int N,out int i,out vec2 s){for(i=0;i<N;++i){x=o+d*dir;sid(x,s);if(s.x<5.e-4)return ;if(exit)return ;d+=step;}}"
"\nmarch(march_main,main_scene,x.z>6.2,min(s.x,8.e-3))"
"march(march_reflected,main_scene,x.z>6.2,min(s.x,1.e-2))"
"march(march_shadow,main_scene,x.z>.2,min(s.x,1.e-2))"
""
"float sm(in float d)"
"{"
"return smoothstep(1.5/iResolution.y,-1.5/iResolution.y,d);"
"}"
""
"void floor_texture(in vec2 uv,out vec3 col)"
"{"
"vec2 na;"
"lfnoise(12.*uv,na.x);"
"lfnoise(12.*uv-1337.,na.y);"
"na=.5+.5*na;"
""
"float v;"
"vec2 vi;"
"dsmoothvoronoi(12.*uv-.8*na,.3,v,vi);"
"v/=12.;"
"v=abs(v)-.0001;"
""
"float d=v;"
""
"dsmoothvoronoi(32.*uv-2.4*na,.3,v,vi);"
"v/=32.;"
"v=abs(v)-.0001;"
""
"smoothmin(d,v,.018*na.y,d);"
""
"col=mix(c.yyy,2.*vec3 (0.83,0.02,0.02),sm(d/2.5));"
"col=mix(col,2.*vec3 (0.83,0.82,0.02),sm(d));"
""
"}"
""
"void illuminate(in vec3 x,in vec3 n,in vec3 dir,in vec3 l,inout vec3 col,in vec2 s)"
"{"
"if(s.y==0.){"
"col=1.2*mix(c.xxy,c.xyy,.3);"
"col=.1*col"
"+.5*col*dot(l,n)"
"+.3*col*pow(abs(dot(reflect(l,n),dir)),2.);"
"}"
"else if(s.y==1.){"
"floor_texture(x.xy,col);"
"col=.1*col"
"+.1*col*dot(l,n)"
"+1.1*col*pow(abs(dot(reflect(l,n),dir)),2.);"
"}"
"else if(s.y==2.){"
"col=vec3 (0.83,0.00,0.02);"
"col=1.*col"
"+1.1*col*dot(l,n)"
"+1.1*col*pow(abs(dot(reflect(l,n),dir)),2.);"
"}"
"else if(s.y==3.){"
"col=c.xxx;"
"col=.1*col"
"+.1*col*dot(l,n)"
"+1.1*col*pow(abs(dot(reflect(l,n),dir)),2.);"
"}"
"else if(s.y==4.){"
"col=.2*c.xxx;"
"col=.1*col"
"+.5*col*dot(l,n)"
"+.1*col*pow(abs(dot(reflect(l,n),dir)),2.);"
"}"
"}"
""
"void mainImage(out vec4 fragColor,in vec2 fragCoord)"
"{"
"vec2 uv=(fragCoord-.5*iResolution.xy)/iResolution.y,"
"s,ss,"
"s0;"
"vec3 col=c.yyy,"
"o=c.yzx,"
"o0=o,"
"r=c.xyy,"
"t=c.yyy,"
"u=cross(normalize(t-o),-r),"
"dir,"
"n,"
"x,"
"c1=c.yyy,"
"l,"
"dir0,"
"x0,"
"c2,"
"n0;"
"int N=250,"
"i;"
"float d=0.,d0;"
""
"t+=uv.x*r+uv.y*u;"
"dir=normalize(t-o);"
"d=-(o.z-.2)/dir.z;"
"march_main(x,o,d,dir,N,i,s);"
""
"l=normalize(c.xzx);"
""
"vec3 y=vec3 (mod(x.xy,ssize)-.5*ssize,x.z),"
"yi=round((x-y)/ssize+.5);"
""
"if(i<N)"
"{"
"main_normal(x,n,5.e-4);"
"illuminate(x,n,dir,normalize(l),col,s);"
""
"s0=s;"
"x0=x;"
"o0=o;"
"d0=d;"
"dir0=dir;"
"n0=n;"
""
"o=x;"
"d=1.e-2;"
"ss=s;"
""
"for(int j=0;j<2.;++j)"
"{"
"if(s.y==1.)dir=refract(dir,n,.995);"
"else if(s.y==2.)dir=refract(dir,n,.995);"
"else if(s.y==3.)dir=reflect(dir,n);"
"else if(s.y==4.)dir=refract(dir,n,.995);"
"else break;"
""
"march_reflected(x,o,d,dir,N,i,s);"
""
"if(i<N)"
"{"
"main_normal(x,n,5.e-5);"
"illuminate(x,n,dir,normalize(l),c1,s);"
""
"if(s.y==1.)col=mix(col,c1,.1);"
"else if(s.y==2.)col=mix(col,c1,.5);"
"else col=c1;"
"}"
""
"o=x;"
"d=1.e-2;"
"ss=s;"
"}"
"}else d0=-1.;"
""
"o=o0;"
"dir=dir0;"
"x=x0;"
"s=s0;"
""
"{"
"o=x;"
"dir=normalize(l-o);"
"d=1.e-2;"
""
"march_shadow(x,o,d,dir,N,i,s);"
""
"if(i<N)"
"{"
"}"
"}"
""
""
"col*=2.*col;"
""
"dlinesegment(uv,-.4*c.xy,.4*c.xy,d);"
"col=mix(col,mix(col,c.yyy,.9),sm(d-.05));"
"d=abs(d-.05)-.005;"
"col=mix(col,c.xxx,sm(d));"
"d=abs(d-.006)-.001;"
"col=mix(col,.5*c.xxx,sm(d));"
""
"dlinesegment(uv,-.4*c.xy,(.8*iProgress-.4)*c.xy,d);"
"d-=.04;"
"col=mix(col,mix(.7,1.,uv.y/.05)*c.xxx,sm(d));"
""
"fragColor=vec4 (clamp(col,0.,1.),1.);"
"}"
""
"void main()"
"{"
"mainImage(gl_FragColor,gl_FragCoord.xy);"
"}"
;
const char *randSource =
"\n#version 130"
"\nvoid rand(in vec2 x,out float n)"
"{"
"x+=400.;"
"n=fract(sin(dot(sign(x)*abs(x),vec2 (12.9898,78.233)))*43758.5453);"
"}"
;
const char *lfnoiseSource =
"\n#version 130"
"\nconst vec3 c=vec3 (1.,0.,-1.);"
"void rand(in vec2 x,out float d);"
"void lfnoise(in vec2 t,out float n)"
"{"
"vec2 i=floor(t);"
"t=fract(t);"
"t=smoothstep(c.yy,c.xx,t);"
"vec2 v1,v2;"
"rand(i,v1.x);"
"rand(i+c.xy,v1.y);"
"rand(i+c.yx,v2.x);"
"rand(i+c.xx,v2.y);"
"v1=c.zz+2.*mix(v1,v2,t.y);"
"n=mix(v1.x,v1.y,t.x);"
"}"
;
const char *smoothminSource =
"\n#version 130"
"\n"
"void smoothmin(in float a,in float b,in float k,out float dst)"
"{"
"float h=max(k-abs(a-b),0.0)/k;"
"dst=min(a,b)-h*h*h*k*(1.0/6.0);"
"}"
;
const char *dsmoothvoronoiSource =
"\n#version 130"
"\n"
"uniform float iTime;"
"uniform float iFader0;"
""
"const vec3 c=vec3 (1.,0.,-1.);"
""
"void lfnoise(in vec2 t,out float n);"
"void smoothmin(in float a,in float b,in float k,out float dst);"
"void rand(in vec2 x,out float d);"
""
"void dsmoothvoronoi(in vec2 x,in float sm,out float d,out vec2 z)"
"{"
"float n;"
""
"vec2 y=floor(x);"
"float ret=1.;"
"vec2 pf=c.yy,p;"
"float df=10.;"
""
"for(int i=-1;i<=1;i+=1)"
"for(int j=-1;j<=1;j+=1)"
"{"
"p=y+vec2 (float (i),float (j));"
"float pa;"
"rand(p,pa);"
"p+=pa;"
""
"d=length(x-p);"
""
"if(d<df)"
"{"
"df=d;"
"pf=p;"
"}"
"}"
"for(int i=-1;i<=1;i+=1)"
"for(int j=-1;j<=1;j+=1)"
"{"
"p=y+vec2 (float (i),float (j));"
"float pa;"
"rand(p,pa);"
"p+=pa;"
""
"vec2 o=p-pf;"
"d=length(.5*o-dot(x-pf,o)/dot(o,o)*o);"
"smoothmin(ret,d,sm,ret);"
"}"
""
"d=ret;"
"z=pf;"
"}"
;
const char *dbox3Source =
"\n#version 130"
"\nvoid dbox3(in vec3 x,in vec3 b,out float d)"
"{"
"vec3 da=abs(x)-b;"
"d=length(max(da,0.0))"
"+min(max(da.x,max(da.y,da.z)),0.0);"
"}"
;
const char *zextrudeSource =
"void zextrude(in float z,in float d2d,in float h,out float d)"
"{"
"vec2 w=vec2 (d2d,abs(z)-0.5*h);"
"d=min(max(w.x,w.y),0.0)+length(max(w,0.0));"
"}"
;
const char *addSource =
"void add(in vec2 sda,in vec2 sdb,out vec2 sdf)"
"{"
"sdf=(sda.x<sdb.x)?sda:sdb;"
"}"
;
const char *dlinesegmentSource =
"\n#version 130"
"\n"
"void dlinesegment(in vec2 x,in vec2 p1,in vec2 p2,out float d)"
"{"
"vec2 da=p2-p1;"
"d=length(x-mix(p1,p2,clamp(dot(x-p1,da)/dot(da,da),0.,1.)));"
"}"
;

LoadingBar::LoadingBar(SymbolTable *_symbolTable)
    : symbolTable(_symbolTable)
    , ownShader(new Shader(loadingBarSource))
{
    ownShader->compile();
    Shader *randShader = new Shader(randSource, "rand");
    symbolTable->addSymbol(randShader);
    Shader *lfnoiseShader = new Shader(lfnoiseSource, "lfnoise");
    symbolTable->addSymbol(lfnoiseShader);
    Shader *smoothminShader = new Shader(smoothminSource, "smoothmin");
    symbolTable->addSymbol(smoothminShader);
    Shader *dsmoothvoronoiShader = new Shader(dsmoothvoronoiSource, "dsmoothvoronoi");
    symbolTable->addSymbol(dsmoothvoronoiShader);
    Shader *dbox3Shader = new Shader(dbox3Source, "dbox3");
    symbolTable->addSymbol(dbox3Shader);
    Shader *zextrudeShader = new Shader(zextrudeSource, "zextrude");
    symbolTable->addSymbol(zextrudeShader);
    Shader *addShader = new Shader(addSource, "add");
    symbolTable->addSymbol(addShader);
    Shader *dlinesegmentShader = new Shader(dlinesegmentSource, "dlinesegment");
    symbolTable->addSymbol(dlinesegmentShader);
    symbolTable->compileContainedSymbols();
    ownProgram = new Program();
    ownProgram->attachShader(ownShader);
    ownProgram->attachShader(randShader);
    ownProgram->attachShader(lfnoiseShader);
    ownProgram->attachShader(smoothminShader);
    ownProgram->attachShader(dsmoothvoronoiShader);
    ownProgram->attachShader(dbox3Shader);
    ownProgram->attachShader(zextrudeShader);
    ownProgram->attachShader(addShader);
    ownProgram->attachShader(dlinesegmentShader);
    ownProgram->link();
    ownProgram->use();
    ownProgram->handleUniform("iResolution");
    ownProgram->handleUniform("iProgress");
}
